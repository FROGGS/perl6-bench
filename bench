#!/usr/bin/env perl6

# ABSTRACT: Master console/"porcelain" for Perl language family benchmarking tools

use v6;
use JSON::Tiny;
use Shell::Command;


# Reduce directory insanity a bit by changing to bench root
my $PROGRAM_DIR = ~($*PROGRAM_NAME ~~ /^(.*\/)/) || './';
chdir $PROGRAM_DIR;
$PROGRAM_DIR = cwd;
my $COMPONENTS_DIR = "$PROGRAM_DIR/components";

# This ends up getting used all over the place;
# might as well just load it at startup
my $COMPONENTS = from-json(slurp "$PROGRAM_DIR/components.json");


# MAIN COMMANDS

#= Show benchmark configuration
multi MAIN ('config') {
    print qq:to/CONFIG/;
        Benchmark root:    $PROGRAM_DIR
        Perl 6 program:    $*EXECUTABLE_NAME
        Perl 6 version:    $*PERL<compiler>< name ver build-date >
        Known components:  $COMPONENTS.keys.sort.join(', ')
        CONFIG
}

#= Prepare for mass benchmarking
multi MAIN ('setup') {
    say 'Creating directories ...';
    mkdir 'components' unless 'components'.IO.d;
    mkdir 'results'    unless 'results'.IO.d;

    say 'Cloning component repos ...';
    for $COMPONENTS.values -> $component {
        my $name = $component<name>;
        say "==> $name";

        chdir $COMPONENTS_DIR;
        mkdir $name unless $name.IO.d;
        chdir $name;

        my $repo = $component<repo_url>;
        my $bare = "$name.git";
        say "----> Already cloned." if $bare.IO.d && $name.IO.d;
        run < git clone --bare >, $repo, $bare unless $bare.IO.d;
        run < git clone -l     >, $bare, $name unless $name.IO.d;
    }

    say 'Setup complete.';
}

#= Fetch latest commits in each cloned component
multi MAIN ('fetch', *@components) {
    needs-setup('fetch');

    for explode-components(@components) -> $comp {
        my $name = $comp<info><name>;
        say "==> $name";

        my $bare = "$name/$name.git";
        unless $bare.IO.d {
            say "No bare repository exists for component $name; can't fetch updates.";
            next;
        }

        %*ENV<GIT_DIR> = $bare;
        run < git fetch >;
    }
}

#= Alias for 'extract'
multi MAIN ('extract-releases', *@components) { MAIN('extract', |@components) }

#= Extract historical releases from cloned components
multi MAIN ('extract', *@components) {
    needs-setup('extract releases');

    for explode-components(@components) -> $comp {
        my $name = $comp<info><name>;
        say "==> $name";

        chdir "$COMPONENTS_DIR/$name";

        my $bare = "$name.git";
        unless $bare.IO.d {
            say "No bare repository exists for component $name; can't extract releases.";
            next;
        }

        my @tags;
        if $comp<checkouts> {
            @tags = @($comp<checkouts>);
        }
        else {
            # Determine which release tags to check out by default
            my $tag_regex = $comp<info><release_tags>;
            next unless $tag_regex;

            %*ENV<GIT_DIR> = $bare;
            my $tag_list = open 'git tag', :p;
            @tags = grep / <{ $tag_regex }> /, $tag_list.lines;
            %*ENV.delete('GIT_DIR');
        }

        # Work around Rakudo bug #115390 by splitting into two loops
        for @tags -> $tag {
            next if $tag.IO.d;
            run < git clone -l >, $bare, $tag;
        }
        for @tags -> $tag {
            chdir $tag; LEAVE chdir '..';
            run < git checkout -q >, $tag;   # > -- Dang syntax highlighting
        }
    }

    say 'Extraction complete.';
}

#= Build checked out component trees
multi MAIN ('build', *@components) {
    needs-setup('build components');

    for explode-components(@components) -> $comp {
        my $name = $comp<info><name>;
        say "==> $name";

        my @checkouts = $comp<checkouts>;
        for $comp<checkouts>.list -> $checkout {
            say "----> $checkout";
            chdir "$COMPONENTS_DIR/$name/$checkout";

            my $build_steps = $comp<info><build_steps>;
            for $build_steps.list -> $step {
                $step ~~ Positional ?? run(|$step) !! shell($step);
            }
        }
    }
}

#= Clean up build trees in components/, keeping bare clones by default
multi MAIN ('clean', *@components) {
    unless $COMPONENTS_DIR.IO.d {
        say "No 'components' tree exists, so there is nothing to clean.";
        exit;
    }

    for explode-components(@components) -> $comp {
        my $name = $comp<info><name>;
        say "==> $name";

        my @checkouts = $comp<checkouts>;
        for $comp<checkouts>.list -> $checkout {
            rmtree "$COMPONENTS_DIR/$name/$checkout";
        }
    }
}

#= Remove *everything* not part of the core benchmark tree
multi MAIN ('realclean', Bool :$force) {
    unless $force {
        print q:to/NEED_FORCE/;  # : -- Dang syntax highlighting
            Are you sure?
            
            This command will wipe your benchmarking tree clean, destroying any builds,
            cloned components, and benchmark results in the process.  You will need
            to use the --force option if you really want to do this.
            NEED_FORCE
        exit;
    }

    # OK, you asked for it!
    say "OK, performing realclean.";
    rmtree $_ for < components results >;
    run < git clean -dxf >;
}

#= Perform benchmark timings
multi MAIN ('timeall', *@options) {
    run('./timeall', |@options);
}

#= Analyze results from benchmark timings
multi MAIN ('analyze', *@options_and_files) {
    run('./analyze', |@options_and_files);
}


# UTILITY ROUTINES

#= Check whether 'setup' command has been run and bail out if not
sub needs-setup ($action) {
    unless $COMPONENTS_DIR.IO.d {
        say "There is no 'components' tree, and thus there are no repos to $action.";
        say "Please run `$*PROGRAM_NAME setup`.";
        exit 1;
    }
}

#= Simulate the behavior of `git clean -dxf`
sub rmtree ($dir, :$noisy = True) {
    return unless $dir.IO.d;
    say "Removing $dir" if $noisy;
    rm_rf $dir;
}

#= Expand a partially-specified list of components and checkouts
sub explode-components (@component-specs, :$chdir = True, :$default-to-dirs = True) {
    chdir $COMPONENTS_DIR if $chdir;
    @component-specs ||= dir('.').sort if $default-to-dirs;

    my @exploded;
    for @component-specs -> $spec is copy {
        # Remove optional leading 'components/', which helps with tab completion
        $spec .= subst(/^ 'components/' /, '');  # ' -- Damn syntax highlighting
        die "Don't know what to do with empty component specification" unless $spec.chars;

        my ($component, $checkouts) = $spec.split: '/';
        my $comp-info = $COMPONENTS{$component};
        die "Don't know how to process component '$component'" unless $comp-info;

        my @checkouts;
        if $checkouts.defined && $checkouts.chars {
            @checkouts = $checkouts.split: ',';
        }
        else {
            my $bare   = "$component.git";
            @checkouts = dir("$COMPONENTS_DIR/$component",
                            test => none('.', '..', $bare)).sort;
        }

        if @exploded.first(*.<info><name> eq $component) -> $comp {
            $comp<checkouts>.push: |@checkouts;
        }
        else {
            @exploded.push: { info => $comp-info, checkouts => @checkouts };
        }
    }

    return @exploded;
}
