#!/usr/bin/env perl

# ABSTRACT: Benchmark and compare perl5 and various Perl 6 implementations

use 5.010;
use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;
use Time::HiRes     'time';
use File::Temp      'tempfile';
use List::Util      'min', 'max';
use List::MoreUtils 'uniq';
use Capture::Tiny   'capture';
use FindBin;
use Cwd;


my %DEFAULT = (
               TEST_COUNT => 5,
              );
my @GROUPS    = qw( perl5 nqp perl6 );
my %VM        = (
                 perl5   => 'perl',
                 node_js => 'node',
                 mono    => 'mono-sgen',
                 v8      => 'BENCH/../v8/out/native/d8',
                );
my %COMPILERS = (
                 perl5 => [
                           {
                            name      => 'perl5',
                            enabled   => 1,
                            language  => 'Perl 5',
                            compiler  => 'perl5',
                            vm        => 'perl5',
                            dir       => 'BENCH',
                            f_run     => [$VM{perl5}          ],
                            e_run     => [$VM{perl5}, qw( -E )],
                           },
                           {
                            name      => 'p5.pl',
                            enabled   => 1,
                            language  => 'Perl 5',
                            compiler  => 'perlito5',
                            vm        => 'perl5',
                            dir       => 'BENCH/../Perlito',
                            f_run     => [$VM{perl5}, qw( -Ilib5 perlito5.pl -Isrc5/lib    )],
                            e_run     => [$VM{perl5}, qw( -Ilib5 perlito5.pl -Isrc5/lib -e )],
                           },
                           {
                            name      => 'p5.js_node',
                            enabled   => 1,
                            language  => 'Perl 5',
                            compiler  => 'perlito5',
                            vm        => 'node.js',
                            dir       => 'BENCH/../Perlito',
                            f_run     => [$VM{node_js}, qw( perlito5.js -Isrc5/lib    )],
                            e_run     => [$VM{node_js}, qw( perlito5.js -Isrc5/lib -e )],
                           },
                           {
                            name      => 'p5.js_v8',
                            enabled   => 1,
                            language  => 'Perl 5',
                            compiler  => 'perlito5',
                            vm        => 'd8',
                            dir       => 'BENCH/../Perlito',
                            f_compile => [$VM{v8}, qw( perlito5.js -- -Isrc5/lib -Cjs    )],
                            e_compile => [$VM{v8}, qw( perlito5.js -- -Isrc5/lib -Cjs -e )],
                            f_run     => [$VM{v8}, qw( COMPILED -- )],
                            e_run     => [$VM{v8}, qw( COMPILED -- )],
                           },
                          ],
                 perl6 => [
                           {
                            name      => 'rakudo',
                            enabled   => 1,
                            language  => 'Perl 6',
                            compiler  => 'rakudo',
                            vm        => 'parrot',
                            dir       => 'BENCH/../rakudo',
                            f_run     => [qw( install/bin/perl6    )],
                            e_run     => [qw( install/bin/perl6 -e )],
                           },
                           {
                            name      => 'niecza',
                            enabled   => 1,
                            language  => 'Perl 6',
                            compiler  => 'niecza',
                            vm        => 'mono',
                            dir       => 'BENCH/../niecza',
                            f_run     => [$VM{mono}, qw( run/Niecza.exe    )],
                            e_run     => [$VM{mono}, qw( run/Niecza.exe -e )],
                           },
                           {
                            name      => 'p6.pl',
                            enabled   => 1,
                            language  => 'Perl 6',
                            compiler  => 'perlito6',
                            vm        => 'perl5',
                            dir       => 'BENCH/../Perlito',
                            f_compile => [$VM{perl5}, qw( -Ilib5 perlito6.pl -Cperl5    )],
                            e_compile => [$VM{perl5}, qw( -Ilib5 perlito6.pl -Cperl5 -e )],
                            f_run     => [$VM{perl5}, qw( -Ilib5 COMPILED )],
                            e_run     => [$VM{perl5}, qw( -Ilib5 COMPILED )],
                           },
                           {
                            name      => 'p6.js_v8',
                            enabled   => 1,
                            language  => 'Perl 6',
                            compiler  => 'perlito6',
                            vm        => 'd8',
                            dir       => 'BENCH/../Perlito',
                            f_compile => [$VM{v8}, qw( perlito6.js -- -Cjs    )],
                            e_compile => [$VM{v8}, qw( perlito6.js -- -Cjs -e )],
                            f_run     => [$VM{v8}, qw( COMPILED -- )],
                            e_run     => [$VM{v8}, qw( COMPILED -- )],
                           },
                          ],
                 nqp   => [
                           {
                            name      => 'nqp',
                            enabled   => 1,
                            language  => 'NQP',
                            compiler  => 'nqp',
                            vm        => 'parrot',
                            dir       => 'BENCH/../nqp',
                            f_run     => [qw( install/bin/nqp --vmlibs=math_ops    )],
                            e_run     => [qw( install/bin/nqp --vmlibs=math_ops -e )],
                           },
                           {
                            name      => 'rakudo.nqp',
                            enabled   => 1,
                            language  => 'NQP',
                            compiler  => 'rakudo',
                            vm        => 'parrot',
                            dir       => 'BENCH/../rakudo',
                            f_run     => [qw( install/bin/perl6    )],
                            e_run     => [qw( install/bin/perl6 -e )],
                           },
                          ],
                );
my %TESTS = (
             e => [
                   {
                    name  => 'empty',
                    perl5 => '',
                    perl6 => '',
                    nqp   => '',
                   },
                   {
                    name  => 'zero',
                    perl5 => '0',
                    perl6 => '0',
                    nqp   => '0',
                   },
                   {
                    name  => 'hello',
                    perl5 => 'say "Hello, World!"',
                    perl6 => 'say "Hello, World!"',
                    nqp   => 'say("Hello, World!")',
                   },
                   {
                    name  => 'empty_loop_1e5',
                    perl5 => '1 for 1 .. 100000',
                    perl6 => '1 for 1 .. 100000',
                    nqp   => 'my $i := 1; while $i <= 100000 { $i := $i + 1; 1 }',
                   },
                   {
                    name  => 'empty_loop_1e6',
                    perl5 => '1 for 1 .. 1000000',
                    perl6 => '1 for 1 .. 1000000',
                    nqp   => 'my $i := 1; while $i <= 1000000 { $i := $i + 1; 1 }',
                   },
                  ],
             f => [
                   {
                    name  => 'rc-forest-fire',
                    skip  => [qw( p6.js_v8 )],
                    perl5 => [qw( BENCH/perl5/rc-forest-fire 30 20 10 )],
                    perl6 => [qw( BENCH/perl6/rc-forest-fire 30 20 10 )],
                    nqp   => [qw( BENCH/nqp/rc-forest-fire 30 20 10 )],
                   },
                  ],
            );
my %FORMATTER = (
                 text => \&summarize_results,
                );


MAIN();

sub MAIN {
    my %opt;
    GetOptions(\%opt, 'help|h|?!', 'man!', 'format=s')
        or pod2usage(-verbose => 0);
    pod2usage(-verbose => 1) if $opt{help};
    pod2usage(-verbose => 2) if $opt{man};

    $opt{format} ||= 'text';
    my $formatter = $FORMATTER{$opt{format}}
        or pod2usage(-msg => "Unknown output format '$opt{format}'");

    my @results;

    eval {
        for my $test_type (sort keys %TESTS) {
            run_tests($test_type, $TESTS{$test_type}, \@results);
        }
    };
    warn "\n$@\n" if $@;

    $formatter->(\@results);
}

sub run_tests {
    my ($test_type, $tests, $results) = @_;

    for my $test (@$tests) {
        my $name  = $test->{name};
        say "Testing $name ...";
        my $raw_times = time_all_compilers($test_type => %$test);
        my $best      = best_times($raw_times);
        my $compared  = compare_times($best);
        push @$results, {
                         name    => $name,
                         conf    => $test,
                         raw     => $raw_times,
                         best    => $best,
                         compare => $compared,
                        };
    }
}

sub time_all_compilers {
    my ($test_type, %opt) = @_;
    my %times;

    for my $group (@GROUPS) {
        time_group($group, $test_type, $COMPILERS{$group}, \%times, \%opt);
    }

    return \%times;
}

sub time_group {
    my ($group_name, $test_type, $group_perls, $times, $opt) = @_;

    my $cwd = cwd;

    for my $perl (@$group_perls) {
        next unless $perl->{enabled};

        my $name = $perl->{name};
        next if grep { $_ eq $name } @{$opt->{skip} || []};

        my $dir  = $perl->{dir} || 'BENCH';
        my $comp = $perl->{"${test_type}_compile"} || [];
        my $run  = $perl->{"${test_type}_run"};
        my $args = $opt->{$group_name};
        my @args = ref $args ? @$args : ($args);

        s/\bBENCH\b/$FindBin::Bin/g for $dir, @$comp, @$run, @args;

        my @compile;
        if (@$comp) {
            # XXXX: This shift is a code smell ...
            @compile = (@$comp, shift @args);
        }
        my @run = (@$run, @args);

        if ($dir) {
            chdir $dir or die "Could not change to $name directory '$dir': $!";
        }

        $times->{$name} = time_command(\@compile, \@run, $opt->{count});
    }

    chdir $cwd;
}

sub time_command {
    my ($compile, $run, $count) = @_;
    $count ||= $DEFAULT{TEST_COUNT};

    my (@times, $status);
    for my $i (1 .. $count) {
        if (@$compile) {
            my $start = time;
            my ($out, $err) = capture { $status = system @$compile };
            if ($status) {
                die "Test's compile command terminated by SIGINT.\n" if ($status & 127) == 2;
                warn "Failed to run compile command: @$compile\n"
                     . (length $err ? "Error:\n$err\n" : '');
                return undef;
            }

            my ($fh, $filename) = tempfile(UNLINK => 1);
            print $fh $out;
            close $fh;
            my @run = @$run;
            s/\bCOMPILED\b/$filename/g for @run;
            $status = system @run;
            push @times, time - $start;
            if ($status) {
                die "Test's run command terminated by SIGINT.\n" if ($status & 127) == 2;
                warn "Failed to run command: @run\n";
                return undef;
            }
        }
        else {
            my $start  = time;
            $status = system @$run;
            push @times, time - $start;
            if ($status) {
                die "Test terminated by SIGINT.\n" if ($status & 127) == 2;
                warn "Failed to run command: @$run\n";
                return undef;
            }
        }
    }

    return \@times;
}

sub best_times {
    my $raw_times = shift;
    my %best;

    while (my ($perl, $times) = each %$raw_times) {
        $best{$perl} = $times ? min(@$times) : undef;
    }

    return \%best;
}

sub compare_times {
    my $times = shift;
    my %relative;

    my @sorted   = sort { $times->{$a} <=> $times->{$b} }
                        grep { defined $times->{$_} } keys %$times;
    my $shortest = $times->{$sorted[0]} || 1e-6;
    for my $perl (@sorted) {
        $relative{$perl} = $times->{$perl} / $shortest;
    }

    return \%relative;
}

sub summarize_results {
    my $times = shift;

    my $RED    = "\e[1;31m";
    my $GREEN  = "\e[32m";
    my $YELLOW = "\e[1;33m";
    my $CLEAR  = "\e[0m";

    my @test_names   = map { $_->{name} } @$times;
    my $longest_test = max 8, map { length } @test_names;

    my @perls        = map { @{$COMPILERS{$_}} } @GROUPS;
       @perls        = grep { $_->{enabled} } @perls;
    my @lang_names   = map { $_->{language} } @perls;
    my @comp_names   = map { $_->{compiler} } @perls;
    my @vm_names     = map { $_->{vm}       } @perls;
    my $longest_perl = max 8, map { length } @lang_names, @comp_names, @vm_names;

    my $spacer_length = 3;
    my $spacer = ' ' x $spacer_length;
    my $format = join $spacer => "%-${longest_test}s", (("%${longest_perl}s ") x @perls);

    my %lang_count;
       $lang_count{$_}++ for @lang_names;
    my @langs = uniq @lang_names;
    my @lang_titles = map { center(" $_ ", $lang_count{$_} * ($longest_perl + $spacer_length + 1) - $spacer_length, bg => '-') } @langs;

    print  "$CLEAR\n", join($spacer => ' ' x $longest_test, @lang_titles), "\n";
    printf "$format\n", '',     @comp_names;
    printf "$format\n", 'TEST', @vm_names;

    for my $test (@$times) {
        printf "%-${longest_test}s", $test->{name};
        for my $perl (@perls) {
            my $name = $perl->{name};
            my $best = $test->{best}{$name};
            if (defined $best) {
                printf "$spacer%${longest_perl}.3fs", $test->{best}{$name};
            }
            else {
                printf "$spacer%${longest_perl}s ", '-- ';
            }
        }
        print "\n";

        printf "%-${longest_test}s", '';
        for my $perl (@perls) {
            my $name = $perl->{name};
            my $rel  = $test->{compare}{$name};
            if (defined $rel) {
                my $color = $rel <  2 ? $GREEN  :
                            $rel < 10 ? $YELLOW :
                                        $RED    ;
                printf "$spacer$color%${longest_perl}.3fx$CLEAR", $rel;
            }
            else {
                my $is_skip = grep { $_ eq $name } @{$test->{conf}{skip} || []};
                printf "$spacer$RED%${longest_perl}s $CLEAR",
                       $is_skip ? 'SKIP' : 'FAIL';
            }
        }
        print "\n";
    }
}

sub center {
    my ($string, $length, %opts) = @_;

    my $bg_char = $opts{bg} || ' ';
    my $output  = $bg_char x ($length / length $bg_char);
    my $left    = int(($length - length $string) / 2);
    substr($output, $left, length $string, $string);

    return $output;
}


__END__

=head1 NAME

bench -- Benchmark Perl-family compilers against each other


=head1 SYNOPSIS

    bench [--help|-h|-?] [--man] [--format=text]


=head1 DESCRIPTION

This program benchmarks a number of implementations of Perl-family languages
against each other doing various simple tasks.  For a given task, each
language uses a similar algorithm, but written in the appropriate colloquial
style.  For a given language, all relevant implementations execute exactly
the same program for each task, or are marked as unable to process that task.

The simplest tasks are executed using each implementation's "evaluate a string
from the command line" option, generally C<-e> or C<-E>.  More complex tasks
are composed of matching scripts sorted into subdirectories by language,
optionally with additional command line arguments.


=head1 OPTIONS

=over 4

=item --help|-h|-?

Get basic help for this program

=item --man

Display this program's entire manpage

=item --format=text

Format the summary output in a particular format.  The default is 'text',
which outputs a text-rendered summary table, with ANSI coloring.

=back


=head1 AUTHOR

Geoffrey Broadwell


=cut
