#!/usr/bin/env perl

# ABSTRACT: Benchmark and compare perl5 and various Perl 6 implementations

use 5.010;
use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;
use Time::HiRes     'time';
use File::Temp      'tempfile';
use List::Util      'min', 'max';
use List::MoreUtils 'uniq';
use Capture::Tiny   'capture';
use File::Basename;
use IO::File;
use FindBin;
use JSON;
use Cwd;


my %DEFAULT = (
               TEST_COUNT => 5,
              );
my @GROUPS    = qw( perl5 nqp perl6 );
my %VM        = (
                 perl5   => 'perl',
                 node_js => 'node',
                 mono    => 'mono-sgen',
                 v8      => 'BENCH/../v8/out/native/d8',
                );
my %COMPILERS = (
                 perl5 => [
                           {
                            name      => 'perl5',
                            enabled   => 1,
                            language  => 'Perl 5',
                            compiler  => 'perl5',
                            vm        => 'perl5',
                            dir       => 'BENCH',
                            f_run     => [$VM{perl5}          ],
                            e_run     => [$VM{perl5}, qw( -E )],
                           },
                           {
                            name      => 'p5.pl',
                            enabled   => 1,
                            language  => 'Perl 5',
                            compiler  => 'perlito5',
                            vm        => 'perl5',
                            dir       => 'BENCH/../Perlito',
                            f_run     => [$VM{perl5}, qw( -Ilib5 perlito5.pl -Isrc5/lib    )],
                            e_run     => [$VM{perl5}, qw( -Ilib5 perlito5.pl -Isrc5/lib -e )],
                           },
                           {
                            name      => 'p5.js_node',
                            enabled   => 1,
                            language  => 'Perl 5',
                            compiler  => 'perlito5',
                            vm        => 'node.js',
                            dir       => 'BENCH/../Perlito',
                            f_run     => [$VM{node_js}, qw( perlito5.js -Isrc5/lib    )],
                            e_run     => [$VM{node_js}, qw( perlito5.js -Isrc5/lib -e )],
                           },
                           {
                            name      => 'p5.js_v8',
                            enabled   => 1,
                            language  => 'Perl 5',
                            compiler  => 'perlito5',
                            vm        => 'd8',
                            dir       => 'BENCH/../Perlito',
                            f_compile => [$VM{v8}, qw( perlito5.js -- -Isrc5/lib -Cjs    )],
                            e_compile => [$VM{v8}, qw( perlito5.js -- -Isrc5/lib -Cjs -e )],
                            f_run     => [$VM{v8}, qw( COMPILED -- )],
                            e_run     => [$VM{v8}, qw( COMPILED -- )],
                           },
                          ],
                 perl6 => [
                           {
                            name      => 'rakudo',
                            enabled   => 1,
                            language  => 'Perl 6',
                            compiler  => 'rakudo',
                            vm        => 'parrot',
                            dir       => 'BENCH/../rakudo',
                            f_run     => [qw( install/bin/perl6    )],
                            e_run     => [qw( install/bin/perl6 -e )],
                           },
                           {
                            name      => 'niecza',
                            enabled   => 1,
                            language  => 'Perl 6',
                            compiler  => 'niecza',
                            vm        => 'mono',
                            dir       => 'BENCH/../niecza',
                            f_run     => [$VM{mono}, qw( run/Niecza.exe    )],
                            e_run     => [$VM{mono}, qw( run/Niecza.exe -e )],
                           },
                           {
                            name      => 'p6.pl',
                            enabled   => 1,
                            language  => 'Perl 6',
                            compiler  => 'perlito6',
                            vm        => 'perl5',
                            dir       => 'BENCH/../Perlito',
                            f_compile => [$VM{perl5}, qw( -Ilib5 perlito6.pl -Cperl5    )],
                            e_compile => [$VM{perl5}, qw( -Ilib5 perlito6.pl -Cperl5 -e )],
                            f_run     => [$VM{perl5}, qw( -Ilib5 COMPILED )],
                            e_run     => [$VM{perl5}, qw( -Ilib5 COMPILED )],
                           },
                           {
                            name      => 'p6.js_v8',
                            enabled   => 1,
                            language  => 'Perl 6',
                            compiler  => 'perlito6',
                            vm        => 'd8',
                            dir       => 'BENCH/../Perlito',
                            f_compile => [$VM{v8}, qw( perlito6.js -- -Cjs    )],
                            e_compile => [$VM{v8}, qw( perlito6.js -- -Cjs -e )],
                            f_run     => [$VM{v8}, qw( COMPILED -- )],
                            e_run     => [$VM{v8}, qw( COMPILED -- )],
                           },
                          ],
                 nqp   => [
                           {
                            name      => 'nqp',
                            enabled   => 1,
                            language  => 'NQP',
                            compiler  => 'nqp',
                            vm        => 'parrot',
                            dir       => 'BENCH/../nqp',
                            f_run     => [qw( install/bin/nqp --vmlibs=math_ops    )],
                            e_run     => [qw( install/bin/nqp --vmlibs=math_ops -e )],
                           },
                           {
                            name      => 'rakudo.nqp',
                            enabled   => 1,
                            language  => 'NQP',
                            compiler  => 'rakudo',
                            vm        => 'parrot',
                            dir       => 'BENCH/../rakudo',
                            f_run     => [qw( install/bin/perl6    )],
                            e_run     => [qw( install/bin/perl6 -e )],
                           },
                          ],
                );
my %TESTS = (
             e => [
                   {
                    name  => 'empty',
                    perl5 => '',
                    perl6 => '',
                    nqp   => '',
                   },
                   {
                    name  => 'zero',
                    perl5 => '0',
                    perl6 => '0',
                    nqp   => '0',
                   },
                   {
                    name  => 'hello',
                    perl5 => 'say "Hello, World!"',
                    perl6 => 'say "Hello, World!"',
                    nqp   => 'say("Hello, World!")',
                   },
                   {
                    name  => 'empty_loop_1e5',
                    perl5 => '1 for 1 .. 100000',
                    perl6 => '1 for 1 .. 100000',
                    nqp   => 'my $i := 1; while $i <= 100000 { $i := $i + 1; 1 }',
                   },
                   {
                    name  => 'empty_loop_1e6',
                    perl5 => '1 for 1 .. 1000000',
                    perl6 => '1 for 1 .. 1000000',
                    nqp   => 'my $i := 1; while $i <= 1000000 { $i := $i + 1; 1 }',
                   },
                  ],
             f => [
                   {
                    name  => 'rc-forest-fire',
                    skip  => [qw( p6.js_v8 )],
                    perl5 => [qw( BENCH/perl5/rc-forest-fire 30 20 10 )],
                    perl6 => [qw( BENCH/perl6/rc-forest-fire 30 20 10 )],
                    nqp   => [qw( BENCH/nqp/rc-forest-fire 30 20 10 )],
                   },
                  ],
            );
my %FORMATTER = (
                 json         => \&summarize_results_json,
                 text         => \&summarize_results_text,
                 html         => \&summarize_results_html,
                 html_snippet => \&summarize_results_html_snippet,
                );


MAIN();

sub MAIN {
    # Process options
    my %opt;
    GetOptions(\%opt, 'help|h|?!', 'man!', 'format=s', 'style=s', 'outfile=s')
        or pod2usage(-verbose => 0);
    pod2usage(-verbose => 1) if $opt{help};
    pod2usage(-verbose => 2) if $opt{man};

    $opt{outfile} //= '-';
    my $suffix      = (fileparse($opt{outfile}, qr/\.[^.]+$/))[2] || '.';
    my $ext         = lc substr $suffix, 1;

    $opt{format}  //= exists $FORMATTER{$ext} ? $ext : 'text';
    $opt{format}    = lc $opt{format};
    my $formatter   = $FORMATTER{$opt{format}}
        or pod2usage(-msg => "Unknown output format '$opt{format}'");

    $opt{style}   //= 'auto';
    $opt{style}     = lc $opt{style};
    (grep {$_ eq $opt{style}} 0, 1, 'auto')
        or pod2usage(-msg => "Unknown output style setting '$opt{style}'");

    # Open outfile
    my $out_fh = $opt{outfile} eq '-' ? \*STDOUT : IO::File->new($opt{outfile}, '>')
        or die "Could not open outfile '$opt{outfile}': $!";

    # Record general test configuration and info
    my %config = (
                  default   => \%DEFAULT,
                  groups    => \@GROUPS,
                  vm        => \%VM,
                  compilers => \%COMPILERS,
                  tests     => \%TESTS,
                 );

    my $bench_rev = `git describe --always --dirty`;
    chomp $bench_rev;
    my %run       = (
                     start_time => time,
                     bench_rev  => $bench_rev,
                    );

    # Run tests
    my @results;

    eval {
        for my $test_type (sort keys %TESTS) {
            run_tests($test_type, $TESTS{$test_type}, \@results);
        }
    };
    warn "\n$@\n" if $@;

    $run{end_time} = time;

    # Output results
    $formatter->(\%config, \%run, \@results, $opt{style}, $out_fh);
}

sub run_tests {
    my ($test_type, $tests, $results) = @_;

    for my $test (@$tests) {
        my $name  = $test->{name};
        say "Testing $name ...";
        my $raw_times = time_all_compilers($test_type => %$test);
        my $best      = best_times($raw_times);
        my $compared  = compare_times($best);
        push @$results, {
                         name    => $name,
                         conf    => $test,
                         raw     => $raw_times,
                         best    => $best,
                         compare => $compared,
                        };
    }
}

sub time_all_compilers {
    my ($test_type, %opt) = @_;
    my %times;

    for my $group (@GROUPS) {
        time_group($group, $test_type, $COMPILERS{$group}, \%times, \%opt);
    }

    return \%times;
}

sub time_group {
    my ($group_name, $test_type, $group_perls, $times, $opt) = @_;

    my $cwd = cwd;

    for my $perl (@$group_perls) {
        next unless $perl->{enabled};

        my $name = $perl->{name};
        next if grep { $_ eq $name } @{$opt->{skip} || []};

        my $dir  = $perl->{dir} || 'BENCH';
        my $comp = $perl->{"${test_type}_compile"} || [];
        my $run  = $perl->{"${test_type}_run"};
        my $args = $opt->{$group_name};
        my @args = ref $args ? @$args : ($args);

        s/\bBENCH\b/$FindBin::Bin/g for $dir, @$comp, @$run, @args;

        my @compile;
        if (@$comp) {
            # XXXX: This shift is a code smell ...
            @compile = (@$comp, shift @args);
        }
        my @run = (@$run, @args);

        if ($dir) {
            chdir $dir or die "Could not change to $name directory '$dir': $!";
        }

        $times->{$name} = time_command(\@compile, \@run, $opt->{count});
    }

    chdir $cwd;
}

sub time_command {
    my ($compile, $run, $count) = @_;
    $count ||= $DEFAULT{TEST_COUNT};

    my (@times, $status);
    for my $i (1 .. $count) {
        if (@$compile) {
            my $start = time;
            my ($out, $err) = capture { $status = system @$compile };
            if ($status) {
                die "Test's compile command terminated by SIGINT.\n" if ($status & 127) == 2;
                warn "Failed to run compile command: @$compile\n"
                     . (length $err ? "Error:\n$err\n" : '');
                return undef;
            }

            my ($fh, $filename) = tempfile(UNLINK => 1);
            print $fh $out;
            close $fh;
            my @run = @$run;
            s/\bCOMPILED\b/$filename/g for @run;
            $status = system @run;
            push @times, time - $start;
            if ($status) {
                die "Test's run command terminated by SIGINT.\n" if ($status & 127) == 2;
                warn "Failed to run command: @run\n";
                return undef;
            }
        }
        else {
            my $start  = time;
            $status = system @$run;
            push @times, time - $start;
            if ($status) {
                die "Test terminated by SIGINT.\n" if ($status & 127) == 2;
                warn "Failed to run command: @$run\n";
                return undef;
            }
        }
    }

    return \@times;
}

sub best_times {
    my $raw_times = shift;
    my %best;

    while (my ($perl, $times) = each %$raw_times) {
        $best{$perl} = $times ? min(@$times) : undef;
    }

    return \%best;
}

sub compare_times {
    my $times = shift;
    my %relative;

    my @sorted   = sort { $times->{$a} <=> $times->{$b} }
                        grep { defined $times->{$_} } keys %$times;
    my $shortest = $times->{$sorted[0]} || 1e-6;
    for my $perl (@sorted) {
        $relative{$perl} = $times->{$perl} / $shortest;
    }

    return \%relative;
}

sub summarize_results_json {
    my ($config, $run, $times, $style, $out_fh) = @_;

    $style = 1 if $style eq 'auto';

    my $encoder = JSON->new->utf8;
       $encoder->pretty if $style;

    my %info = (
                config => $config,
                run    => $run,
                times  => $times,
               );

    my $json = $encoder->encode(\%info);

    print $out_fh $json;
}

sub summarize_results_text {
    my ($config, $run, $times, $style, $out_fh) = @_;

    $style = -t $out_fh
        if $style eq 'auto';

    my $RED    = $style ? "\e[1;31m" : '';
    my $GREEN  = $style ? "\e[32m"   : '';
    my $YELLOW = $style ? "\e[1;33m" : '';
    my $CLEAR  = $style ? "\e[0m"    : '';

    my @test_names   = map { $_->{name} } @$times;
    my $longest_test = max 8, map { length } @test_names;

    my @perls        = map { @{$COMPILERS{$_}} } @GROUPS;
       @perls        = grep { $_->{enabled} } @perls;
    my @lang_names   = map { $_->{language} } @perls;
    my @comp_names   = map { $_->{compiler} } @perls;
    my @vm_names     = map { $_->{vm}       } @perls;
    my $longest_perl = max 8, map { length } @lang_names, @comp_names, @vm_names;

    my $spacer_length = 3;
    my $spacer = ' ' x $spacer_length;
    my $format = join $spacer => "%-${longest_test}s", (("%${longest_perl}s ") x @perls);

    my %lang_count;
       $lang_count{$_}++ for @lang_names;
    my @langs = uniq @lang_names;
    my @lang_titles = map { center(" $_ ", $lang_count{$_} * ($longest_perl + $spacer_length + 1) - $spacer_length, bg => '-') } @langs;

    my $start  = friendly_time($run->{start_time});
    my $output = "perl6-bench rev $run->{bench_rev} run at $start\n\n";

    $output .= "$CLEAR\n" . join($spacer => ' ' x $longest_test, @lang_titles) . "\n";
    $output .= sprintf "$format\n", '',     @comp_names;
    $output .= sprintf "$format\n", 'TEST', @vm_names;

    for my $test (@$times) {
        $output .= sprintf "%-${longest_test}s", $test->{name};
        for my $perl (@perls) {
            my $name = $perl->{name};
            my $best = $test->{best}{$name};
            if (defined $best) {
                $output .= sprintf "$spacer%${longest_perl}.3fs", $test->{best}{$name};
            }
            else {
                $output .= sprintf "$spacer%${longest_perl}s ", '-- ';
            }
        }
        $output .= "\n";

        $output .= sprintf "%-${longest_test}s", '';
        for my $perl (@perls) {
            my $name = $perl->{name};
            my $rel  = $test->{compare}{$name};
            if (defined $rel) {
                my $color = $rel <  2 ? $GREEN  :
                            $rel < 10 ? $YELLOW :
                                        $RED    ;
                $output .= sprintf "$spacer$color%${longest_perl}.3fx$CLEAR", $rel;
            }
            else {
                my $is_skip = grep { $_ eq $name } @{$test->{conf}{skip} || []};
                $output .= sprintf "$spacer$RED%${longest_perl}s $CLEAR",
                       $is_skip ? 'SKIP' : 'FAIL';
            }
        }
        $output .= "\n";
    }

    print $out_fh $output;
}

sub center {
    my ($string, $length, %opts) = @_;

    my $bg_char = $opts{bg} || ' ';
    my $output  = $bg_char x ($length / length $bg_char);
    my $left    = int(($length - length $string) / 2);
    substr($output, $left, length $string, $string);

    return $output;
}

sub summarize_results_html {
    my ($config, $run, $times, $style, $out_fh) = @_;

    # Default to including style in full HTML pages
    $style = 1
        if $style eq 'auto';

    print $out_fh <<'HEADER';
<html>
<head>
<title>Perl Bench Summary</title>
</head>

<body>
HEADER

    summarize_results_html_snippet($config, $run, $times, $style, $out_fh);

    print $out_fh <<'FOOTER';
</body>
</html>
FOOTER
}

sub summarize_results_html_snippet {
    my ($config, $run, $times, $style, $out_fh) = @_;
    my $html = '';

    # Default to no style info if just generating an HTML snippet
    $style = 0
        if $style eq 'auto';

    if ($style) {
        $html .= <<'CSS';
<style type="text/css">
bench_language { text-align: center; }
bench_compiler { text-align: center; }
bench_vm       { text-align: center; }
bench_time     { text-align: right; font-family: monospace; }
bench_no_time  { text-align: right; font-family: monospace; }
bench_good     { text-align: right; font-family: monospace; color: green;  }
bench_bad      { text-align: right; font-family: monospace; color: yellow; }
bench_ugly     { text-align: right; font-family: monospace; color: red;    }
bench_skip     { text-align: right; font-family: monospace; color: red;    }
bench_fail     { text-align: right; font-family: monospace; color: red;    }
</style>

CSS
    }

    my @test_names   = map { $_->{name} } @$times;
    my @perls        = map { @{$COMPILERS{$_}} } @GROUPS;
       @perls        = grep { $_->{enabled} } @perls;
    my @lang_names   = map { $_->{language} } @perls;
    my @comp_names   = map { $_->{compiler} } @perls;
    my @vm_names     = map { $_->{vm}       } @perls;

    my %lang_count;
       $lang_count{$_}++ for @lang_names;
    my @langs = uniq @lang_names;

    $html .= qq{<table class="bench_summary">\n};
    $html .= qq{<caption>perl6-bench rev $run->{bench_rev} run at } . friendly_time($run->{start_time}) . qq{</caption>\n};
    $html .= "<tr><th></th>\n"     . join('' => map qq{    <th class="bench_language" colspan="$lang_count{$_}">$_</th>\n} => @langs) . "</tr>\n";
    $html .= "<tr><th></th>\n"     . join('' => map qq{    <th class="bench_compiler">$_</th>\n} => @comp_names) . "</tr>\n";
    $html .= "<tr><th>TEST</th>\n" . join('' => map qq{    <th class="bench_vm">$_</th>\n} => @vm_names) . "</tr>\n";

    for my $test (@$times) {
        $html .= "<tr><td>$test->{name}</td>\n";
        for my $perl (@perls) {
            my $name = $perl->{name};
            my $best = $test->{best}{$name};
            if (defined $best) {
                $html .= sprintf qq{    <td class="bench_time">%.3fs</td>\n}, $test->{best}{$name};
            }
            else {
                $html .= qq{    <td class="bench_no_time">--</td>\n};
            }
        }
        $html .= "</tr>\n";

        $html .= "<tr><td></td>\n";
        for my $perl (@perls) {
            my $name = $perl->{name};
            my $rel  = $test->{compare}{$name};
            if (defined $rel) {
                my $class = $rel <  2 ? 'bench_good' :
                            $rel < 10 ? 'bench_bad'  :
                                        'bench_ugly' ;
                $html .= sprintf qq{    <td class="$class">%.3fx</td>\n}, $rel;
            }
            else {
                my $is_skip = grep { $_ eq $name } @{$test->{conf}{skip} || []};
                my $class   = $is_skip ? 'bench_skip' : 'bench_fail';
                my $message = $is_skip ? 'SKIP'       : 'FAIL';
                $html .= qq{    <td class="$class">$message</td>\n};
            }
        }
        $html .= "</tr>\n";
    }
    $html .= "</table>\n";

    print $out_fh $html;
}

sub friendly_time {
    my $time     = shift;
    my $dt       = DateTime->from_epoch(epoch => $time);
    my $friendly = $dt->ymd . ' ' . $dt->hms;

    return $friendly;
}


__END__

=head1 NAME

bench -- Benchmark Perl-family compilers against each other


=head1 SYNOPSIS

    bench [--help|-h|-?] [--man] [--format=text|json|html|html_snippet]
          [--style=0|1|auto] [--outfile=path/to/file.ext]


=head1 DESCRIPTION

This program benchmarks a number of implementations of Perl-family languages
against each other doing various simple tasks.  For a given task, each
language uses a similar algorithm, but written in the appropriate colloquial
style.  For a given language, all relevant implementations execute exactly
the same program for each task, or are marked as unable to process that task.

The simplest tasks are executed using each implementation's "evaluate a string
from the command line" option, generally C<-e> or C<-E>.  More complex tasks
are composed of matching scripts sorted into subdirectories by language,
optionally with additional command line arguments.


=head1 OPTIONS

=over 4

=item --help|-h|-?

Get basic help for this program

=item --man

Display this program's entire manpage

=item --format=text|json|html|html_snippet

Format the summary output in a particular format.  If the C<--outfile> option
is set, then the default output format is based on the lowercased extension
of the output filename.  Otherwise the default is C<text>, which outputs a
text-rendered summary table with ANSI coloring.  HTML output is also available,
either in full document form (C<html>), or just a snippet containing the
summary table (C<html_snippet>).  To save the results in computer-friendly
form, use the C<json> format.

=item --style=0|1|auto

Select whether style settings are included in the output.  C<0> turns off
style output, C<1> turns it on, and C<auto> (the default) tries to DWIM.
For text output, this option selects whether ANSI color codes are used to
highlight entries in the summary table; C<auto> turns on ANSI color whenever
the output is a TTY.  For HTML output, this determines whether a CSS style
block is added to the HTML (element C<class> attributes are always output).
C<auto> defaults to adding CSS to full HTML documents (format C<html>), and
I<not> adding it to HTML snippets (format C<html_snippet>).  If style is
on (or auto) for JSON output (format C<json>), the result will be
pretty-printed; otherwise it will be output in compact form.

=item --outfile=path/to/file.ext|-

Write the summary report to a particular path and file, or to STDOUT (the
default) if C<--outfile> is set to C<-> (a single hyphen).  If this option
is set and C<--format> is not, then the summary format defaults to the
lowercased extension (F<ext> in F<path/to/file.ext>) of the C<--outfile>.

=back


=head1 AUTHOR

Geoffrey Broadwell


=cut
