#!/usr/bin/env perl6

# ABSTRACT: Master console/"porcelain" for Perl language family benchmarking tools

use v6;
use JSON::Tiny;


# Reduce directory insanity a bit by changing to bench root
my ($PROGRAM_DIR) = ~($*PROGRAM_NAME ~~ /^(.*\/)/) // './';
chdir $PROGRAM_DIR;
$PROGRAM_DIR = cwd;
my $COMPONENTS_DIR = "$PROGRAM_DIR/components";

# This ends up getting used all over the place;
# might as well just load it at startup
my $COMPONENTS = from-json(slurp "$PROGRAM_DIR/components.json");


#= Show benchmark configuration
multi MAIN ('config') {
    say "Benchmark root:  $PROGRAM_DIR";
    say "Perl 6 program:  $*EXECUTABLE_NAME";
    say "Perl 6 version:  $*PERL<compiler>< name ver build-date >";
}

#= Prepare for mass benchmarking
multi MAIN ('setup') {
    say 'Creating directories ...';
    mkdir 'components' unless 'components'.IO.d;
    mkdir 'results'    unless 'results'.IO.d;

    say 'Cloning component repos ...';
    for $COMPONENTS.values -> $component {
        my $name = $component<name>;
        say "==> $name";

        chdir $COMPONENTS_DIR;
        mkdir $name unless $name.IO.d;
        chdir $name;

        my $repo = $component<repo_url>;
        my $bare = "$name.git";
        run < git clone --bare >, $repo, $bare unless $bare.IO.d;
        run < git clone -l     >, $bare, $name unless $name.IO.d;
    }

    say 'Setup complete.';
}

#= Fetch latest commits in each cloned component
multi MAIN ('fetch') {
    needs-setup('fetch');

    chdir $COMPONENTS_DIR;

    for dir('.').sort -> $component-name {
        say "==> $component-name";

        my $bare = "$component-name/$component-name.git";
        unless $bare.IO.d {
            say "No bare repository exists for component $component-name; can't fetch updates.";
            next;
        }

        %*ENV<GIT_DIR> = $bare;
        run < git fetch >;
    }
}

sub needs-setup ($action) {
    unless $COMPONENTS_DIR.IO.d {
        say "There is no 'components' tree, and thus there are no repos to $action.";
        say "Please run `$*PROGRAM_NAME setup`.";
        exit 1;
    }
}

#= Extract historical releases from cloned components
multi MAIN ('extract-releases', *@components) {
    needs-setup('extract releases');

    chdir $COMPONENTS_DIR;
    @components ||= dir('.').sort;

    for @components -> $component-name {
        say "==> $component-name";
        chdir "$COMPONENTS_DIR/$component-name";

        my $bare = "$component-name.git";
        unless $bare.IO.d {
            say "No bare repository exists for component $component-name; can't extract releases.";
            next;
        }

        my $tag_regex = $COMPONENTS{$component-name}<release_tags> || '.';
        %*ENV<GIT_DIR> = $bare;
        my $tag_list = open 'git tag', :p;
        my @tags = grep / <{ $tag_regex }> /, $tag_list.lines;
        %*ENV.delete('GIT_DIR');

        # Work around Rakudo bug #115390 by splitting into two loops
        for @tags -> $tag {
            next if $tag.IO.d;
            run < git clone -l >, $bare, $tag;
        }
        for @tags -> $tag {
            chdir $tag; LEAVE chdir '..';
            run < git checkout -q >, $tag;   # > -- Dang syntax highlighting
        }
    }

    say 'Extraction complete.';
}

#= Build checked out component trees
multi MAIN ('build', *@components) {
    needs-setup('build components');

    chdir $COMPONENTS_DIR;
    @components ||= dir('.').sort;

    for @components -> $component-name {
        say "==> $component-name";
        my $bare = "$component-name.git";
        my @checkouts = dir($component-name, test => none('.', '..', $bare)).sort;

        for @checkouts -> $checkout {
            chdir "$COMPONENTS_DIR/$component-name/$checkout";

            my $build_steps = $components{$component-name}<build_steps>;
            for $build_steps.list -> $step {
                if $step ~~ Positional {
                    # run |$step;
		    say "run: $step";
                }
                else {
                    # shell $step;
		    say "shell: $step";
                }
            }
        }
    }
}

#= Clean up generated files and directories
multi MAIN ('clean') {
    rmtree $_ for < components results >;
}

#= Simulate the behavior of `git clean -dxf`
sub rmtree ($dir, :$noisy = True) {
    return unless $dir.IO.d;
    say "Removing $dir" if $noisy;
    run < rm -rf >, $dir;
}

#= Remove *everything* not part of the core benchmark tree
multi MAIN ('realclean') {
    run < git clean -dxf >;
}

#= Perform benchmark timings
multi MAIN ('timeall', *@options) {
    run('./timeall', |@options);
}

#= Analyze results from benchmark timings
multi MAIN ('analyze', *@options_and_files) {
    run('./analyze', |@options_and_files);
}
