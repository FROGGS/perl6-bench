#!/usr/bin/env perl6

# ABSTRACT: Master console/"porcelain" for Perl language family benchmarking tools

use v6;
use JSON::Tiny;


# Reduce directory insanity a bit by changing to bench root
my ($PROGRAM_DIR) = ~($*PROGRAM_NAME ~~ /^(.*\/)/) // './';
chdir $PROGRAM_DIR;
$PROGRAM_DIR = cwd;
my $COMPONENTS_DIR = "$PROGRAM_DIR/components";


#= Show benchmark configuration
multi MAIN ('config') {
    say "Benchmark root:  $PROGRAM_DIR";
    say "Perl 6 program:  $*EXECUTABLE_NAME";
    say "Perl 6 version:  $*PERL<compiler>< name ver build-date >";
}

#= Prepare for mass benchmarking
multi MAIN ('setup') {
    say 'Creating directories ...';
    mkdir 'components' unless 'components'.IO.d;
    mkdir 'results'    unless 'results'.IO.d;

    say 'Parsing components.json ...';
    my $components = from-json(slurp 'components.json');

    say 'Cloning component repos ...';
    for $components.values -> $component {
        my $name = $component<name>;
        say "==> $name";

        chdir $COMPONENTS_DIR;
        mkdir $name unless $name.IO.d;
        chdir $name;

        my $repo = $component<repo_url>;
        my $bare = "$name.git";
        run < git clone --bare >, $repo, $bare unless $bare.IO.d;
        run < git clone -l     >, $bare, $name unless $name.IO.d;
    }

    say 'Setup complete.';
}

#= Fetch latest commits in each cloned component
multi MAIN ('fetch') {
    needs-setup('fetch');

    chdir $COMPONENTS_DIR;

    for dir('.').sort -> $component-name {
        say "==> $component-name";

        my $bare = "$component-name/$component-name.git";
        unless $bare.IO.d {
            say "No bare repository exists for component $component-name; can't fetch updates.";
            next;
        }

        %*ENV<GIT_DIR> = $bare;
        run < git fetch >;
    }
}

sub needs-setup ($action) {
    unless $COMPONENTS_DIR.IO.d {
        say "There is no 'components' tree, and thus there are no repos to $action.";
        say "Please run `$*PROGRAM_NAME setup`.";
        exit 1;
    }
}

multi MAIN ('build') {
        # %*ENV<GIT_DIR> = $bare;
        # my $tag_list = open 'git tag', :p;
        # my @tags = $tag_list.lines;
        # .say for @tags;
}

#= Clean up generated files and directories
multi MAIN ('clean') {
    rmtree $_ for < components results >;
}

#= Simulate the behavior of `git clean -dxf`
sub rmtree ($dir, :$noisy = True) {
    return unless $dir.IO.d;
    say "Removing $dir" if $noisy;
    run < rm -rf >, $dir;
}

#= Remove *everything* not part of the core benchmark tree
multi MAIN ('realclean') {
    run < git clean -dxf >;
}

#= Perform benchmark timings
multi MAIN ('timeall', *@options) {
    run('./timeall', |@options);
}

#= Analyze results from benchmark timings
multi MAIN ('analyze', *@options_and_files) {
    run('./analyze', |@options_and_files);
}
