#!/usr/bin/env perl

# ABSTRACT: Benchmark and compare perl5 and various Perl 6 implementations

use 5.010;
use strict;
use warnings;
use Time::HiRes 'time';
use List::Util  'min', 'max';
use FindBin;
use Cwd;


my %DEFAULT = (
               TEST_COUNT => 5,
              );
my @GROUPS    = qw( perl5 nqp perl6 );
my %COMPILERS = (
                 perl5 => [
                           {
                            name  => 'perl5',
                            dir   => 'BENCH',
                            f_run => [qw( perl    )],
                            e_run => [qw( perl -E )],
                           },
                           {
                            name  => 'p5.pl',
                            dir   => 'BENCH/../Perlito',
                            f_run => [qw( perl -Ilib5 perlito5.pl -Isrc5/lib    )],
                            e_run => [qw( perl -Ilib5 perlito5.pl -Isrc5/lib -e )],
                           },
                           {
                            name  => 'p5.js',
                            dir   => 'BENCH/../Perlito',
                            f_run => [qw( node perlito5.js -Isrc5/lib    )],
                            e_run => [qw( node perlito5.js -Isrc5/lib -e )],
                           },
                          ],
                 perl6 => [
                           {
                            name  => 'rakudo',
                            dir   => 'BENCH/../rakudo',
                            f_run => [qw( install/bin/perl6    )],
                            e_run => [qw( install/bin/perl6 -e )],
                           },
                           {
                            name  => 'niecza',
                            dir   => 'BENCH/../niecza',
                            f_run => [qw( mono-sgen run/Niecza.exe    )],
                            e_run => [qw( mono-sgen run/Niecza.exe -e )],
                           },
                          ],
                 nqp   => [
                           {
                            name  => 'nqp',
                            dir   => 'BENCH/../nqp',
                            f_run => [qw( install/bin/nqp --vmlibs=math_ops    )],
                            e_run => [qw( install/bin/nqp --vmlibs=math_ops -e )],
                           },
                          ],
                );
my @TESTS_E = (
               {
                name  => 'empty',
                perl5 => '',
                perl6 => '',
                nqp   => '',
               },
               {
                name  => 'zero',
                perl5 => '0',
                perl6 => '0',
                nqp   => '0',
               },
               {
                name  => 'hello',
                perl5 => 'say "Hello, World!"',
                perl6 => 'say "Hello, World!"',
                nqp   => 'say("Hello, World!")',
               },
               {
                name  => 'empty_loop_1e5',
                perl5 => '1 for 1 .. 100000',
                perl6 => '1 for 1 .. 100000',
                nqp   => 'my $i := 1; while $i <= 100000 { $i++; 1 }',
               },
              );
my @TESTS_F = (
               {
                name  => 'rc-forest-fire',
                perl5 => [qw( BENCH/perl5/rc-forest-fire 30 20 10 )],
                perl6 => [qw( BENCH/perl6/rc-forest-fire 30 20 10 )],
                nqp   => [qw( BENCH/nqp/rc-forest-fire 30 20 10 )],
               },
              );


MAIN();

sub MAIN {
    my $times_e = run_tests_e();
    my $times_f = run_tests_f();

    summarize_results([@$times_e, @$times_f]);
}

sub run_tests_e {
    my @times;

    for my $test (@TESTS_E) {
        my $name  = $test->{name};
        say "Testing $name ...";
        my $raw_times = time_all_compilers(e => %$test);
        my $best      = best_times($raw_times);
        my $compared  = compare_times($best);
        push @times, {
                      name    => $name,
                      raw     => $raw_times,
                      best    => $best,
                      compare => $compared,
                     };
    }

    return \@times;
}

sub run_tests_f {
    my @times;

    for my $test (@TESTS_F) {
        my $name  = $test->{name};
        say "Testing $name ...";
        my $raw_times = time_all_compilers(f => %$test);
        my $best      = best_times($raw_times);
        my $compared  = compare_times($best);
        push @times, {
                      name    => $name,
                      raw     => $raw_times,
                      best    => $best,
                      compare => $compared,
                     };
    }

    return \@times;
}

sub time_all_compilers {
    my ($test_type, %opt) = @_;
    my %times;

    for my $group (@GROUPS) {
        time_group($group, $test_type, $COMPILERS{$group}, \%times, \%opt);
    }

    return \%times;
}

sub time_group {
    my ($group_name, $test_type, $group_perls, $times, $opt) = @_;

    my $cwd = cwd;

    for my $perl (@$group_perls) {
        my $name = $perl->{name};
        my $dir  = $perl->{dir} || 'BENCH';
        my $cmd  = $perl->{"${test_type}_run"};
        my $args = $opt->{$group_name};
        my @args = ref $args ? @$args : ($args);
        my @cmd  = (@$cmd, @args);

        s/\bBENCH\b/$FindBin::Bin/g for $dir, @cmd;

        if ($dir) {
            chdir $dir or die "Could not change to $name directory '$dir': $!";
        }

        $times->{$name} = time_command(\@cmd, $opt->{count});
    }

    chdir $cwd;
}

sub time_command {
    my ($cmd, $count) = @_;
    $count ||= $DEFAULT{TEST_COUNT};

    my @times;
    for my $i (1 .. $count) {
        my $start  = time;
        my $status = system @$cmd;
        push @times, time - $start;
        if ($status) {
            warn "Failed to run command: @$cmd\n";
            return undef;
        }
    }

    return \@times;
}

sub best_times {
    my $raw_times = shift;
    my %best;

    while (my ($perl, $times) = each %$raw_times) {
        $best{$perl} = $times ? min(@$times) : undef;
    }

    return \%best;
}

sub compare_times {
    my $times = shift;
    my %relative;

    my @sorted   = sort { $times->{$a} <=> $times->{$b} }
                        grep { defined $times->{$_} } keys %$times;
    my $shortest = $times->{$sorted[0]} || 1e-6;
    for my $perl (@sorted) {
        $relative{$perl} = $times->{$perl} / $shortest;
    }

    return \%relative;
}

sub summarize_results {
    my $times = shift;

    my $RED    = "\e[1;31m";
    my $GREEN  = "\e[32m";
    my $YELLOW = "\e[1;33m";
    my $CLEAR  = "\e[0m";

    say '';

    my @test_names   = map { $_->{name} } @$times;
    my $longest_test = max 8, map { length } @test_names;

    my @perl_names   = map { $_->{name} } map { @{$COMPILERS{$_}} } @GROUPS;
    my $longest_perl = max 8, map { length } @perl_names;

    my $spacer = '   ';
    my $format = join $spacer => "%-${longest_test}s", (("%${longest_perl}s ") x @perl_names);
    printf "$format\n", 'TEST', map {uc} @perl_names;

    for my $test (@$times) {
        printf "%-${longest_test}s", $test->{name};
        for my $perl (@perl_names) {
            my $best = $test->{best}{$perl};
            if (defined $best) {
                printf "$spacer%${longest_perl}.3fs", $test->{best}{$perl};
            }
            else {
                printf "$spacer%${longest_perl}s ", '-- ';
            }
        }
        print "\n";

        printf "%-${longest_test}s", '';
        for my $perl (@perl_names) {
            my $rel = $test->{compare}{$perl};
            if (defined $rel) {
                my $color = $rel <  2 ? $GREEN  :
                            $rel < 10 ? $YELLOW :
                                        $RED    ;
                printf "$spacer$color%${longest_perl}.3fx$CLEAR", $rel;
            }
            else {
                printf "$spacer$RED%${longest_perl}s $CLEAR", 'FAIL';
            }
        }
        print "\n";
    }
}
