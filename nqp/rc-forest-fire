# XXXX: WIP translation from Perl 6, won't compile in NQP yet!

my $RED     := "\e[1;31m";
my $CLEAR   := "\e[0m";
my $Empty   := 0;
my $Tree    := 1;
my $Burning := 2;
my @show    := ('  ', '木', $RED ~ '木' ~ $CLEAR);

class Forest {
    has @!grid;
    has @!neighbors;
    has $!height;
    has $!width;
    has $!p;
    has $!f;

    method new($height, $width, $p=0.01, $f=0.001) {
        my $c := self.bless(:$height, :$width, :$p, :$f);
        $c.init-grid;
        $c.init-neighbors;
        return $c;
    }

    method init-grid () {
        # @!grid := [ (pir::rand__NN(1.0) < .5 ?? $Tree !! $Empty) xx $!width ] xx $!height;
        @!grid := [];
        my $i := 0;
        while $i < $!height {
            @!grid.push([]);
            my $j := 0;
            while $j < $!width {
                @!grid[$i].push(pir::rand__NN(1.0) < .5 ?? $Tree !! $Empty);
                $j++;
            }
            $i++;
        }
    }

    method init-neighbors () {
        @!neighbors := [];
        my $i := 0;
        while $i < $!height {
            @!neighbors.push([]);
            my $j := 0;
            while $j < $!width {
                @!neighbors[$i].push([]);
                for [-1,-1],[+0,-1],[+1,-1],
                    [-1,+0],(     ),[+1,+0],
                    [-1,+1],[+0,+1],[+1,+1]
                {
                    my $y := $i + $_[0];
                    my $x := $j + $_[1];
                    next if $x < 0 || $x >= $!width;
                    next if $y < 0 || $y >= $!height;

                    my $cell := @!grid[$i + $_[0]][$j + $_[1]];
                    @!neighbors[$i][$j].push($cell);
                }
                $j++;
            }
            $i++;
        }
    }

    method step () {
        my @new;
        my $i := 0;
        while $i < $!height {
            @new.push([]);
            my $j := 0;
            while $j < $!width {
                my $cell := @!grid[$i][$j];
                if    $cell == $Empty {
                    @new[$i][$j] := pir::rand__NN(1.0) < $!p ?? $Tree !! $Empty
                }
                elsif $cell == $Tree {
                    my $burn_tree := 0;
                    for @!neighbors[$i][$j] {
                        $burn_tree := 1 if $_ == $Burning;
                    }
                    $burn_tree := 1 if pir::rand__NN(1.0) < $!f;
                    @new[$i][$j] := $burn_tree ?? $Burning !! $Tree;
                }
                elsif $cell == $Burning {
                    @new[$i][$j] := $Empty
                }
                $j++;
            }
            $i++;
        }
        $i := 0;
        while $i < $!height {
            my $j := 0;
            while $j < $!width {
                @!grid[$i][$j] := @new[$i][$j];
                $j++;
            }
            $i++;
        }
    }

    method Str () {
        my $rows := '';
        my $i := 0;
        while $i < $!height {
            my $row := '';
            my $j := 0;
            while $j < $!width {
                $row := $row ~ @show[@!grid[$i][$j]];
                $j++;
            }
            $rows := $rows ~ $row ~ "\n";
            $i++;
        }
        $rows;
    }
}

sub MAIN ($name, $w, $h, $steps) {
    my $f := Forest.new($h, $w);
    print("\e[2J$CLEAR");      # ANSI clear screen

    my $i := 0;
    until $i >= $steps {
        print("\e[H");   # ANSI home
        say($i++);
        say($f.Str);
        $f.step;
    }
}
