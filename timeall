#!/usr/bin/env perl

# ABSTRACT: Run benchmark timings for various Perl 5, NQP, and Perl 6 implementations

use 5.010;
use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;
use Time::HiRes     'time';
use File::Temp      'tempfile';
use List::Util      'min', 'max';
use List::MoreUtils 'uniq';
use Capture::Tiny   'capture';
use DateTime;
use File::Basename;
use IO::File;
use FindBin;
use JSON;
use Cwd;

my %DEFAULT = (
               TEST_RUNS => 2,
              );
my @GROUPS    = qw( perl5 nqp perl6 );
my %VM        = (
                 perl5   => 'perl',
                 node_js => 'nodejs',
                 mono    => 'mono-sgen',
                 v8      => 'BENCH/../v8/out/native/d8',
                );
my %COMPILERS = (
                 perl5 => [
                           {
                            name      => 'perl5',
                            enabled   => 1,
                            language  => 'Perl 5',
                            compiler  => 'perl5',
                            vm        => 'perl5',
                            dir       => 'BENCH',
                            f_run     => [$VM{perl5}          ],
                            e_run     => [$VM{perl5}, qw( -E )],
                            show_ver  => [$VM{perl5}, qw( -E say+$] )],
                           },
                           {
                            name      => 'p5.pl',
                            enabled   => 1,
                            language  => 'Perl 5',
                            compiler  => 'perlito5',
                            vm        => 'perl5',
                            f_run     => [$VM{perl5}, qw( -Ilib5 perlito5.pl -Isrc5/lib    )],
                            e_run     => [$VM{perl5}, qw( -Ilib5 perlito5.pl -Isrc5/lib -e )],
                            show_ver  => [$VM{perl5}, qw( -Ilib5 perlito5.pl --version     )],
                           },
                           {
                            name      => 'p5.js_node',
                            enabled   => 1,
                            language  => 'Perl 5',
                            compiler  => 'perlito5',
                            vm        => 'node.js',
                            f_run     => [$VM{node_js}, qw( perlito5.js -Isrc5/lib    )],
                            e_run     => [$VM{node_js}, qw( perlito5.js -Isrc5/lib -e )],
                            show_ver  => [$VM{node_js}, qw( perlito5.js --version     )],
                           },
                           {
                            name      => 'p5.js_v8',
                            enabled   => 1,
                            language  => 'Perl 5',
                            compiler  => 'perlito5',
                            vm        => 'd8',
                            f_compile => [$VM{v8}, qw( perlito5.js -- -Isrc5/lib -Cjs    )],
                            e_compile => [$VM{v8}, qw( perlito5.js -- -Isrc5/lib -Cjs -e )],
                            show_ver  => [$VM{v8}, qw( perlito5.js -- --version          )],
                            f_run     => [$VM{v8}, qw( COMPILED -- )],
                            e_run     => [$VM{v8}, qw( COMPILED -- )],
                           },
                          ],
                 perl6 => [
                           {
                            name      => 'rakudo',
                            enabled   => 1,
                            language  => 'Perl 6',
                            compiler  => 'rakudo',
                            vm        => 'parrot',
                            f_run     => [qw( install/bin/perl6    )],
                            e_run     => [qw( install/bin/perl6 -e )],
                            show_ver  => [qw( install/bin/perl6 --version )],
                           },
                           {
                            name      => 'niecza',
                            enabled   => 1,
                            language  => 'Perl 6',
                            compiler  => 'niecza',
                            vm        => 'mono',
                            f_run     => [$VM{mono}, qw( run/Niecza.exe    )],
                            e_run     => [$VM{mono}, qw( run/Niecza.exe -e )],
                            show_ver  => [$VM{mono}, qw( run/Niecza.exe --version )],
                           },
                           {
                            name      => 'p6.pl',
                            enabled   => 1,
                            language  => 'Perl 6',
                            compiler  => 'perlito6',
                            vm        => 'perl5',
                            f_compile => [$VM{perl5}, qw( -Ilib5 perlito6.pl -Cperl5    )],
                            e_compile => [$VM{perl5}, qw( -Ilib5 perlito6.pl -Cperl5 -e )],
                            show_ver  => [$VM{perl5}, qw( -Ilib5 perlito6.pl --version  )],
                            f_run     => [$VM{perl5}, qw( -Ilib5 COMPILED )],
                            e_run     => [$VM{perl5}, qw( -Ilib5 COMPILED )],
                           },
                           {
                            name      => 'p6.js_v8',
                            enabled   => 1,
                            language  => 'Perl 6',
                            compiler  => 'perlito6',
                            vm        => 'd8',
                            f_compile => [$VM{v8}, qw( perlito6.js -- -Cjs    )],
                            e_compile => [$VM{v8}, qw( perlito6.js -- -Cjs -e )],
                            show_ver  => [$VM{v8}, qw( perlito6.js -- --version )],
                            f_run     => [$VM{v8}, qw( COMPILED -- )],
                            e_run     => [$VM{v8}, qw( COMPILED -- )],
                           },
                          ],
                 nqp   => [
                           {
                            name      => 'nqp',
                            enabled   => 1,
                            language  => 'NQP',
                            compiler  => 'nqp',
                            vm        => 'parrot',
                            f_run     => [qw( install/bin/nqp --vmlibs=math_ops    )],
                            e_run     => [qw( install/bin/nqp --vmlibs=math_ops -e )],
                            show_ver  => [qw( install/bin/nqp --version            )],
                           },
                           {
                            name      => 'rakudo.nqp',
                            enabled   => 1,
                            language  => 'NQP',
                            compiler  => 'rakudo',
                            vm        => 'parrot',
                            f_run     => [qw( install/bin/perl6    )],
                            e_run     => [qw( install/bin/perl6 -e )],
                            show_ver  => [qw( install/bin/perl6 --version )],
                           },
                           {
                            name      => 'niecza.nqp',
                            enabled   => 1,
                            language  => 'NQP',
                            compiler  => 'niecza',
                            vm        => 'mono',
                            f_run     => [$VM{mono}, qw( run/Niecza.exe    )],
                            e_run     => [$VM{mono}, qw( run/Niecza.exe -e )],
                            show_ver  => [$VM{mono}, qw( run/Niecza.exe --version )],
                           },
                          ],
                );
my %TESTS = (
             e => do "$FindBin::Bin/microbenchmarks.pl",
             f => [
                   {
                    name  => 'rc-forest-fire',
                    skip  => [qw( niecza.nqp p6.pl p6.js_v8 )],
                    perl5 => [qw( BENCH/perl5/rc-forest-fire 30 20 10 )],
                    perl6 => [qw( BENCH/perl6/rc-forest-fire 30 20 10 )],
                    nqp   => [qw( BENCH/nqp/rc-forest-fire   30 20 10 )],
                   },
                   {
                    name  => 'rc-man-or-boy-test',
                    skip  => [qw( )],
                    perl5 => [qw( BENCH/perl5/rc-man-or-boy-test 16 )],
                    perl6 => [qw( BENCH/perl6/rc-man-or-boy-test 16 )],
                    nqp   => [qw( BENCH/nqp/rc-man-or-boy-test   16 )],
                   },
                  ],
            );
my %FORMATTER = (
                 json         => \&summarize_results_json,
                );
my $START_CWD = cwd;


MAIN();

sub MAIN {
    # Process options
    my %opt;
    GetOptions(\%opt, 'help|h|?!', 'man!', 'list-variants!', 'list-tests!',
                      'runs=i', 'format=s', 'outfile=s', 'tests=s')
        or pod2usage(-verbose => 0);
    pod2usage(-verbose => 1) if $opt{help};
    pod2usage(-verbose => 2) if $opt{man};
    list_variants()          if $opt{'list-variants'};
    list_tests()             if $opt{'list-tests'};

    $opt{outfile} //= 'bench-' . DateTime->today->ymd . '.json';
    my $suffix      = (fileparse($opt{outfile}, qr/\.[^.]+$/))[2] || '.';
    my $ext         = lc substr $suffix, 1;

    $opt{format}  //= exists $FORMATTER{$ext} ? $ext : 'text';
    $opt{format}    = lc $opt{format};
    my $formatter   = $FORMATTER{$opt{format}}
        or pod2usage(-msg => "Unknown output format '$opt{format}'");

    # Open outfile
    my $out_fh = $opt{outfile} eq '-' ? \*STDOUT : IO::File->new($opt{outfile}, '>')
        or die "Could not open outfile '$opt{outfile}': $!";

    # Allow selecting a subset of available compilers
    if (@ARGV) {
        for my $set (values %COMPILERS) {
            for my $compiler (@$set) {
                $compiler->{enabled} = 0 unless grep {$_ eq $compiler->{name}} @ARGV;
            }
        }
    }

    # Allow selecting a subset of available tests
    my $empty_test = $TESTS{e}[0];
    if ($opt{tests}) {
        my %enabled = map {($_ => 1)} split ',' => $opt{tests};

        while (my ($test_type, $tests) = each %TESTS) {
            my @enabled;
            for my $test (@$tests) {
                push @enabled, $test if $enabled{$test->{name}};
            }
            $TESTS{$test_type} = \@enabled;
        }
    }

    # Record general test configuration and info
    my %config = (
                  default   => \%DEFAULT,
                  groups    => \@GROUPS,
                  vm        => \%VM,
                  compilers => \%COMPILERS,
                  tests     => \%TESTS,
                 );

    my %run    = (
                  start_time => time,
                  options    => \%opt,
                  versions   => detect_versions(),
                 );

    # Run tests
    my (@results, $startup);
    my $runs = $opt{runs} || $DEFAULT{TEST_RUNS};

    eval {
        say "Measuring startup times ...";
        my $times = time_all_compilers($runs, e => %$empty_test);
        $startup  = best_times($times);

        for my $test_type (sort keys %TESTS) {
            run_tests($test_type, $TESTS{$test_type}, \@results, $startup, $runs);
        }
    };
    warn "\n$@\n" if $@;

    $run{end_time} = time;

    # Output results
    $formatter->(\%config, \%run, \@results, $out_fh);
    say "Benchmark data written to '$opt{outfile}'."
        if $opt{outfile} ne '-';
}

sub list_variants {
    my $format = "%-10s   %-8s   %-7s   %-6s\n";

    printf $format, qw( VARIANT COMPILER VM LANGUAGE );

    my @compilers = sort { $a->{name} cmp $b->{name} }
                    map  @$_, values %COMPILERS;

    for my $compiler (@compilers) {
        printf $format, @$compiler{qw( name compiler vm language )};
    }

    exit 0;
}

sub list_tests {
    my @tests = map @{$TESTS{$_}}, sort keys %TESTS;
    my @names = map $_->{name}, @tests;

    print "$_\n" for @names;

    exit 0;
}

sub detect_versions {
    say "Detecting versions ...";

    my %version;
    my $cwd = cwd;

    my @detect_git_rev = qw( git describe --always --dirty );

    for my $group (@GROUPS) {
        for my $compiler (@{$COMPILERS{$group}}) {
            next unless $compiler->{enabled};

            my $dir = $compiler->{dir} || $START_CWD;
            my @cmd = @{$compiler->{show_ver}};
            s/\bBENCH\b/$FindBin::Bin/g for $dir, @cmd;

            chdir $dir;
            $version{$compiler->{name}} = -d '.git' ? `@detect_git_rev` : `@cmd`;
        }
    }

    chdir $FindBin::Bin;
    $version{bench} = `@detect_git_rev`;

    chomp for values %version;

    chdir $cwd;
    return \%version;
}

# Checks if the currently checked out git rev contains all commits from
# ("is greater than or equal to") some other rev
sub git_rev_ge {
    my $ver = shift;

    return unless -d '.git';

    my $old_ver    = `git rev-parse $ver^0`;             chomp $old_ver;
    my $cur_ver    = `git rev-parse HEAD`;               chomp $cur_ver;
    my $merge_base = `git merge-base $old_ver $cur_ver`; chomp $merge_base;

    return $merge_base eq $old_ver;
}

sub run_tests {
    my ($test_type, $tests, $results, $startup, $runs) = @_;

    for my $test (@$tests) {
        my $name  = $test->{name};
        say "Testing $name ...";
        my $raw_times = time_all_compilers($runs, $test_type => %$test);
        my $best      = best_times($raw_times);
        my $cooked    = subtract_times($best, $startup);
        push @$results, {
                         name    => $name,
                         conf    => $test,
                         raw     => $raw_times,
                         best    => $best,
                         cooked  => $cooked,
                        };
    }
}

sub time_all_compilers {
    my ($runs, $test_type, %opt) = @_;
    my %times;

    for my $group (@GROUPS) {
        time_group($runs, $group, $test_type, $COMPILERS{$group}, \%times, \%opt);
    }

    return \%times;
}

sub time_group {
    my ($runs, $group_name, $test_type, $group_perls, $times, $opt) = @_;

    my $cwd = cwd;

    for my $perl (@$group_perls) {
        next unless $perl->{enabled};

        my $name = $perl->{name};
        my $skip = $opt->{skip};
        if ($skip) {
            next if ref $skip eq 'CODE'  && $skip->($perl);
            next if ref $skip eq 'ARRAY' && grep { $_ eq $name } @$skip;
        }

        my $dir  = $perl->{dir} || $START_CWD;
        my $comp = $perl->{"${test_type}_compile"} || [];
        my $run  = $perl->{"${test_type}_run"};
        my $args = $opt->{$group_name} // next;
        my @args = ref $args ? @$args : ($args);

        s/\bBENCH\b/$FindBin::Bin/g for $dir, @$comp, @$run, @args;

        my @compile;
        if (@$comp) {
            # XXXX: This shift is a code smell ...
            @compile = (@$comp, shift @args);
        }
        my @run = (@$run, @args);

        if ($dir) {
            chdir $dir or die "Could not change to $name directory '$dir': $!";
        }

        $times->{$name} = time_command(\@compile, \@run, $runs);
    }

    chdir $cwd;
}

sub time_command {
    my ($compile, $run, $count) = @_;

    my (@times, $status);
    for my $i (1 .. $count) {
        if (@$compile) {
            my $start = time;
            my ($out, $err) = capture { $status = system @$compile };
            if ($status) {
                die "Test's compile command terminated by SIGINT.\n" if ($status & 127) == 2;
                warn "Failed to run compile command: @$compile\n"
                     . (length $err ? "Error:\n$err\n" : '');
                return undef;
            }

            my ($fh, $filename) = tempfile(UNLINK => 1);
            print $fh $out;
            close $fh;
            my @run = @$run;
            s/\bCOMPILED\b/$filename/g for @run;
            $status = system @run;
            push @times, time - $start;
            if ($status) {
                die "Test's run command terminated by SIGINT.\n" if ($status & 127) == 2;
                warn "Failed to run command: @run\n";
                return undef;
            }
        }
        else {
            my $start  = time;
            $status = system @$run;
            push @times, time - $start;
            if ($status) {
                die "Test terminated by SIGINT.\n" if ($status & 127) == 2;
                warn "Failed to run command: @$run\n";
                return undef;
            }
        }
    }

    return \@times;
}

sub best_times {
    my $raw_times = shift;
    my %best;

    while (my ($perl, $times) = each %$raw_times) {
        $best{$perl} = $times ? min(@$times) : undef;
    }

    return \%best;
}

sub subtract_times {
    my ($orig, $offset) = @_;

    return $orig unless $offset;

    my %cooked;

    while (my ($perl, $time) = each %$orig) {
        if ($time) {
            $cooked{$perl} = $time - ($offset->{$perl} || 0);
            $cooked{$perl} = 0 if $cooked{$perl} < 0;
        }
        else {
            $cooked{$perl} = $time;
        }
    }

    return \%cooked;
}

sub summarize_results_json {
    my ($config, $run, $times, $out_fh) = @_;

    my $style = 1;

    my $encoder = JSON->new->utf8->canonical->allow_unknown;
       $encoder->pretty if $style;

    my %info = (
                config => $config,
                run    => $run,
                times  => $times,
               );

    my $json = $encoder->encode(\%info);

    print $out_fh $json;
}


__END__

=head1 NAME

timeall -- Benchmark Perl-family compilers against each other


=head1 SYNOPSIS

    timeall [--help|-h|-?] [--man] [--list-variants] [--list-tests]
    timeall [--runs=2] [--format=json] [--outfile=path/to/file.ext]
            [--tests=list,of,tests] [<enabled compiler variants>]

=head1 DESCRIPTION

This program benchmarks a number of implementations of Perl-family languages
against each other doing various simple tasks.  For a given task, each
language uses a similar algorithm, but written in the appropriate colloquial
style.  For a given language, all relevant implementations execute exactly
the same program for each task, or are marked as unable to process that task.

The simplest tasks are executed using each implementation's "evaluate a string
from the command line" option, generally C<-e> or C<-E>.  These attempt to
use nearly identical code across languages except for required syntax changes,
as with sigil variance/invariance or converting between builtin and
module-loaded functions.  When a language does not provide a given idiom
at all, that task is simply skipped by all implementations of that language.

More complex tasks are composed of matching scripts sorted into subdirectories
by language, optionally with additional command line arguments.  These larger
programs have somewhat more freedom to make use of language-specific idioms,
but care is taken that the basic algorithms and intrinsic complexity are still
the same.  Most (hopefully all) of these can be expressed in every language;
any failures are generally due to limitations of a particular implementation.

Once this script produces a file of timing information, the timing file can
be fed to the F<analyze> script to produce human-friendly summaries of the
timing data.

By default all known implementations of all known languages will be timed
running several iterations of every task, and the best time for each task and
implementation used.  To choose only a subset of the implementations, you may
specify a list of compiler variant names (e.g. C<p5.js_node> for Perlito5
targeting the Node JavaScript VM, or C<rakudo.nqp> for Rakudo running NQP
code instead of its native Perl 6 code) on the command line.  In this case,
only the specified variants will be enabled for that run.  To list the known
compiler variants, use the C<--list-variants> option.

To choose only particular tests to run, specify a comma-separated list of
test names with the C<--tests> option.  To see the list of known names, use
the C<--list-tests> option.


=head1 OPTIONS

=over 4

=item --help|-h|-?

Get basic help for this program

=item --man

Display this program's entire manpage

=item --list-variants

List all known compiler variants

=item --list-tests

List all known tests

=item --runs=2

Set the number of times each test will be run using each compiler variant.
The benchmark code uses the best recorded time across all runs for each test
and compiler combination, so increasing the run count helps to avoid fluke
measurements and the effects of random background processes, but rapidly
reaches diminishing returns.  Many times it's more effective to just turn off
as many background processes (such as email clients) as possible while
benchmarking.

=item --format=json

Format the summary output in a particular format.  If the C<--outfile> option
is set, then the default output format is based on the lowercased extension
of the output filename.  Otherwise the default (and currently only) format is
C<json>, which outputs the results in computer-friendly format suitable for
feeding to the F<analyze> program.

=item --outfile=path/to/file.ext|-

Write the summary report to a particular path and file, or to STDOUT if
C<--outfile> is set to C<-> (a single hyphen).  If this option is set and
C<--format> is not, then the summary format defaults to the lowercased
extension (F<ext> in F<path/to/file.ext>) of the C<--outfile>.  The default
C<--outfile> is F<bench-YYYY-MM-DD.json>, where F<YYYY-MM-DD> is today's date.

=item --tests=list,of,tests

Enable only a subset of the available tests (instead of the default of all
known tests), using a comma separated list of the test names.  To see the
list of known test names, use the C<--list-tests> option.

=back


=head1 AUTHOR

Geoffrey Broadwell


=cut
